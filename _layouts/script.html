---
#layout: default
---
//Jekyll metadata<META>{{ page.url }}<META>{{ page.path }}<META>{{ page.name }}<META>{{ page.title }}<META>{{ page.date }}<META>{{ site.github.build_revision }}
{%- comment -%}
Options 
{%- endcomment -%}
  
{%- assign desciptionWordWrapLength = 7 -%}
  
{%- comment -%}
END OPTIONS
Predefined special characters 
{%- endcomment -%}
  
{% capture NL %}
{% endcapture %}
{% assign COMMENT_NL = NL | append: " *  " %}
{% assign PARAM_NL = COMMENT_NL | append: "@param " %}
{% assign AUTHOR_NL = COMMENT_NL | append: "@author Contributor: " %}
  
{%- comment -%}
END Predefined Special Charaters
Data preprocess
{%- endcomment -%}
  
{%- assign words = page.description | split: " " -%}

{%- if page.params.first -%}
  {%- assign params = page.params -%}
  {%- assign args = page.params | map: 1 | join: ","  -%}
{%- else -%}
 {%- assign params = page.params | split: NL -%}
 {%- comment -%} CURRENTLY NOT DOING THIS BECAUSE ITS GOING TO FAIL A LOT
 {%- assign args = emptyArray -%}
 {%- for param in params -%}
   {%- assign tmp1 = param | strip | split: "}" -%}
   {%- assign tmp2 = tmp1[1] | strip | split: "-" -%}
   {%- assign varName = tmp2[0] | strip -%} 
   {%- assign args = args | push: varName -%}
{%- endif -%}
{%- endcomment -%}
  
{%- if page.returns.first -%}
  {%- assign returns = page.returns | join: " " -%}
{%- else -%}
 {%- assign returns = page.returns | replace: NL, COMMENT_NL -%} 
{%- endif -%}

{%- if page.authors.first -%}
  {%- assign authors = page.authors  -%}
{%- else -%}
 {%- assign authors = page.authors | split: NL  -%} 
{%- endif -%}


  
  
{%- comment -%}
TEMPLATE
{%- endcomment -%}
/**
 *  {% for word in words %}
      {%- assign remainder = forloop.index | modulo: desciptionWordWrapLength -%}
      {%- if remainder == 0 -%}{{ COMMENT_NL }}{%- endif -%}{{ word | append: " " }}
    {% endfor %}
 *  
 *  @param {{ params | join: PARAM_NL }} 
 *  @returns {{ returns }}
 *
 *  @author Original: {{ authors | join: AUTHOR_NL }} 
{%- if page.originalsource -%}{{ COMMENT_NL }}@see OriginalSource: {{ curlyOpen }}@link {{ page.originalsource }}{{ curlyClose }} {% endif %}
 *  @see This is part of a collection of bookmarklets https://ktsuttlemyre.github.io/RogueBookmarklets/
 *  @see Hosted at https://ktsuttlemyre.github.io/RogueBookmarklets{{ page.url }}
 *  @file LastModified: {{ page.date }}
 */

{%- comment -%}
Special vars all functions get (to make them independent)
selection = if there was text selected it is now accessable via this variable
open = similar to window.open but will open modal, window, 
{%- endcomment -%}


if(!Function.prototype.bind){
    //implementatino from https://github.com/Raynos/function-bind
    //repurposed for easy browser pollyfill
    Function.prototype.bind=(function(){
        'use strict';

        /* eslint no-invalid-this: 1 */

        var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
        var slice = Array.prototype.slice;
        var toStr = Object.prototype.toString;
        var funcType = '[object Function]';

        return  function bind(that) {
            var target = this;
            if (typeof target !== 'function' || toStr.call(target) !== funcType) {
                throw new TypeError(ERROR_MESSAGE + target);
            }
            var args = slice.call(arguments, 1);

            var bound;
            var binder = function () {
                if (this instanceof bound) {
                    var result = target.apply(
                        this,
                        args.concat(slice.call(arguments))
                    );
                    if (Object(result) === result) {
                        return result;
                    }
                    return this;
                } else {
                    return target.apply(
                        that,
                        args.concat(slice.call(arguments))
                    );
                }
            };

            var boundLength = Math.max(0, target.length - args.length);
            var boundArgs = [];
            for (var i = 0; i < boundLength; i++) {
                boundArgs.push('$' + i);
            }

            bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

            if (target.prototype) {
                var Empty = function Empty() {};
                Empty.prototype = target.prototype;
                bound.prototype = new Empty();
                Empty.prototype = null;
            }

            return bound;
        };
    })()
};


function allProperties(obj,callback){
    //https://stackoverflow.com/questions/17776830/looping-through-all-of-the-items-in-the-window-object#comment25928156_17776830
    var props;
    if(!callback){
        props=[];
        callback=function(name){props.push(name)}
    }
    do{
        Object.getOwnPropertyNames(obj).forEach(function(name) {
            callback(name);
        });
        console.log("=============================");
    }while(obj = Object.getPrototypeOf(obj));
    return props;
}

function mock(obj,skip){
    skip=skip||[]

    var Mock = function Mock() {};

    var props=allProperties(obj,function(name){
        console.log(name)
        //if(skip.indexOf(name)>=0){return;}
        if(obj[name] && obj[name].bind && typeof obj[name] == 'function'){ //if it is a bindable function
            Mock.prototype[name] = obj[name].bind(obj);
        }else{
            Mock.prototype[name] = obj[name];
        }
    });
    var mock = new Mock();
    Mock.prototype=null
    return mock
}



(function container(window,document,location,alert,prompt,confirm,window.open,undefined){
 
    var RogueBM=window['RogueBM']||{};
    

    //win.document.location='http://google.com'
    var mocks = {
        window:mock(window),
        document:mock(window.document,['location']),
        location:mock(window.document.location)
    }

    //build higherarchy 
    mocks.window.document=mocks.document;
    mocks.window.document.location=mocks.location
    mocks.window.location=mocks.location;

    //custom apis
    //mocks.location.href=location.href.toString()

    var refs=RogueBM['envRefs'];
    var currentCommandID=RogueBM['currentCommandID']
    var alert=mocks.window.alert=function alert(message){
        var skipAlerts=RogueBM['commandChain'][currentCommandID]['skipAlerts'];
        if(skipAlerts){return autoConfirmAnswer;}
        return refs.window.alert(message);
    }
    var confirm=mocks.window.confirm=function confirm(){
        var autoConfirmAnswer=RogueBM['commandChain'][currentCommandID]['autoConfirm'];
        if(typeof autoConfirmAnswer =='boolean'){return autoConfirmAnswer;}
        var args=RogueBM['commandChain']['args'];
        if(args.length){
             var arg=args.shift(); //maybe check if argument is a boolean and enforce it?
             return !!arg;
        }
        return refs.window.confirm(message,value);
    }
    var prompt=mocks.window.prompt=function prompt(message,value){
        var args=RogueBM['commandChain'][currentCommandID]['handoffArgs'];
        if(args.length){
             var arg=args.shift(); //maybe check if argument is string and enforce it?
             return arg;
        }
        return refs.window.prompt(message,value);
    }

    var checkedWindows
    var getSelection=function getSelection(){
        var win,doc;
        if(this==mocks.window){
            win=refs.window
            doc=refs.window.document
        }else{
            win=this;
            doc=this.contentDocument||this.document;
        }
        console.log('getSelection',win,doc);

        var selection=(win.getSelection && win.getSelection() || doc.getSelection && doc.getSelection() || doc.selection && doc.selection.createRange && doc.selection.createRange().text).toString()
        if(selection){
          return selection
        }
        //try to get from frames
        // for(var i=0,l=window.frames.length;i<l;i++){
        //   //call document this way because of IE
        //   //https://stackoverflow.com/questions/17197084/difference-between-contentdocument-and-contentwindow-javascript-iframe-frame-acc
        //   try{
        //       console.log('iframe index',i)
        //       selection=getSelection.call(window.frames[i]); // /*.contentWindow note: that is the contentWindow*/ ,window.frames[i].contentDocument);
        //   }catch(error1){
        //       continue;
        //   }
        //   if(selection){
        //     return selection;
        //     }
        // }
    }
    mocks.window.getSelection=getSelection.bind(mocks.window)
    mocks.document.getSelection=getSelection.bind(mocks.document)

    mocks.document.selection={
        'createRange':function(){
            return {'text': mocks.window.getSelection()}
        }
    }





    var package=function bookmarkletClosure({{args}}){

        var stdout=RogueBM['stdout'];
        var selection = (stdout!=null)?stdout:(getSelection.call(window)||'');
        var serverSecret='{{ site.github.build_revision }}'; //MAKE SURE THIS STATEMENT IS ENDED SO THAT ANY SELFCALLING CLOSURES DON'T GET MISTAKEN FOR A CALL SYNTAX
        //Their code
        {{ page.content }}
        //End their code
    }

    
    if(RogueBM){
        if(RogueBM['execute']){
            var mode=mocks
            RogueBM['execute'](package,mode)
        }
    }else{
        package()
    }

})(window,document,location,alert,prompt,confirm,window.open)
